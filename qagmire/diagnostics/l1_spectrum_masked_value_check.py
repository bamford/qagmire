# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/diagnostics/14_l1_spectrum_masked_value_check.ipynb.

# %% auto 0
__all__ = ['L1SpectrumMaskedValueCheck', 'plot_unmasked_and_invalid']

# %% ../../nbs/diagnostics/14_l1_spectrum_masked_value_check.ipynb 2
import matplotlib.pyplot as plt

from qagmire.data import (
    get_lr_l1_single_files,
    read_l1_data,
)
from ..quality_assurance import Diagnostics

# %% ../../nbs/diagnostics/14_l1_spectrum_masked_value_check.ipynb 4
class L1SpectrumMaskedValueCheck(Diagnostics):
    """L1 spectrum masked value check.

    A reproduction of the class with the same name in the weaveio
    [value_checks](https://github.com/bamford/QAG/blob/master/diagnostics/value_checks.py).

    This tests for the following cases:

    * Are there unmasked pixels (with ivar_noss > 0) where flux_noss < 0?
    * Are there unmasked pixels (with ivar_noss > 0) where flux_noss > linearity_threshold_adu?
    * Are there unmasked pixels (with ivar > 0) where flux_noss < 0?
    * Are there unmasked pixels (with ivar > 0) where flux_noss > linearity_threshold_adu?

    for the red and blue arrays.
    """

    def __init__(
        self,
        linearity_threshold_adu: float = 60000,  # the maximum original ADU to consider valid
        camera=None,  # limit to a specific camera: RED or BLUE
        **kwargs,  # additional keyword arguments are passed to the `Diagnostics` constructor
    ):
        self.linearity_threshold_adu = linearity_threshold_adu
        self.camera = camera.upper() if camera is not None else None
        super().__init__(**kwargs)

    def tests(self, **kwargs):
        files = get_lr_l1_single_files(**kwargs)
        data = read_l1_data(files)

        if self.camera is not None:
            camera_match = data["CAMERA"] == self.camera
            data = data.sel(filename=camera_match)
            cameras = [self.camera]
        else:
            cameras = ["RED", "BLUE"]

        # perform the tests by RUN, rather than filename
        data = data.swap_dims(filename="RUN")
        self.data = data

        tests = []
        for camera in cameras:
            flux_name = f"{camera}_FLUX_NOSS"
            negative_flux = data[flux_name] < 0
            nonlinear_flux = data[flux_name] > self.linearity_threshold_adu

            for ext in ["IVAR", "IVAR_NOSS"]:
                name = f"{camera}_{ext}"
                band = camera[0]
                unmasked = data[name] > 0
                unmasked_negative = unmasked & negative_flux
                unmasked_nonlinear = unmasked & nonlinear_flux
                any_unmasked_negative = unmasked_negative.any(dim=f"LAMBDA_{band}")
                any_unmasked_nonlinear = unmasked_nonlinear.any(dim=f"LAMBDA_{band}")
                tests.extend(
                    [
                        {
                            "name": f"neg_flux_unmasked_in_{name}",
                            "description": f"Are there unmasked pixels in {ext} where FLUX_NOSS is negative?",
                            "test": any_unmasked_negative,
                        },
                        {
                            "name": f"nlr_flux_unmasked_in_{name}",
                            "description": f"Are there unmasked pixels in {ext} where FLUX_NOSS is non-linear?",
                            "test": any_unmasked_nonlinear,
                        },
                    ]
                )
        return tests

# %% ../../nbs/diagnostics/14_l1_spectrum_masked_value_check.ipynb 16
def plot_unmasked_and_invalid(tests, run):
    data = tests.data.sel(RUN=run)
    flux = data[f"{tests.camera}_FLUX_NOSS"]
    neg = flux < 0
    nlr = flux > tests.linearity_threshold_adu
    ivar = data[f"{tests.camera}_IVAR_NOSS"]
    unmasked = ivar > 0
    fig, ax = plt.subplots(2, 1, figsize=(15, 4), sharex=True, sharey=True)
    ax[0].imshow(unmasked, interpolation="none", aspect="auto")
    ax[0].set_title("unmasked")
    ax[1].imshow(-1 * neg + nlr, vmin=-1, vmax=1, interpolation="none", aspect="auto")
    ax[1].set_title("invalid")
    fig.suptitle(f"RUN {run}")
    plt.tight_layout()
