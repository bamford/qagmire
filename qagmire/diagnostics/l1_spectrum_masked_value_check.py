# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/diagnostics/14_l1_spectrum_masked_value_check.ipynb.

# %% auto 0
__all__ = ['L1SpectrumMaskedValueCheck']

# %% ../../nbs/diagnostics/14_l1_spectrum_masked_value_check.ipynb 2
import matplotlib.pyplot as plt

from qagmire.data import (
    get_lr_l1_single_files,
    read_l1_data,
)
from ..quality_assurance import Diagnostics

# %% ../../nbs/diagnostics/14_l1_spectrum_masked_value_check.ipynb 4
class L1SpectrumMaskedValueCheck(Diagnostics):
    """L1 spectrum masked value check.

    A reproduction of the class with the same name in the weaveio
    [value_checks](https://github.com/bamford/QAG/blob/master/diagnostics/value_checks.py).

    This tests for the following cases:

    * Are there unmasked pixels (with ivar_noss > 0) where flux_noss < 0?
    * Are there unmasked pixels (with ivar_noss > 0) where flux_noss > linearity_threshold_adu?
    * Are there unmasked pixels (with ivar > 0) where flux_noss < 0?
    * Are there unmasked pixels (with ivar > 0) where flux_noss > linearity_threshold_adu?

    for the red and blue arrays.
    """

    def __init__(
        self,
        linearity_threshold_adu: float = 60000,  # the maximum original ADU to consider valid
        camera=None,  # limit to a specific camera: RED or BLUE
        **kwargs,  # additional keyword arguments are passed to the `Diagnostics` constructor
    ):
        self.linearity_threshold_adu = linearity_threshold_adu
        self.camera = camera.upper()
        super().__init__(**kwargs)

    def tests(self, **kwargs):
        files = get_lr_l1_single_files(**kwargs)
        data = read_l1_data(files)

        if self.camera is not None:
            camera_match = data["CAMERA"] == self.camera
            data = data.sel(filename=camera_match)
            cameras = [self.camera]
        else:
            cameras = ["RED", "BLUE"]

        # perform the tests by RUN, rather than filename
        data = data.swap_dims(filename="RUN")
        self.data = data

        tests = []
        for camera in cameras:
            camera_match = data["CAMERA"] == camera

            flux_name = f"{camera}_FLUX_NOSS"
            negative_flux = data[flux_name] < 0
            nonlinear_flux = data[flux_name] > self.linearity_threshold_adu

            for ext in ["IVAR", "IVAR_NOSS"]:
                name = f"{camera}_{ext}"
                band = camera[0]
                unmasked = (data[name] > 0) & camera_match
                unmasked_negative = unmasked & negative_flux
                unmasked_nonlinear = unmasked & nonlinear_flux
                any_unmasked_negative = unmasked_negative.any(dim=f"LAMBDA_{band}")
                any_unmasked_nonlinear = unmasked_nonlinear.any(dim=f"LAMBDA_{band}")
                tests.append(
                    {
                        "name": f"neg_flux_unmasked_in_{name}",
                        "description": f"Are there unmasked pixels in {ext} where FLUX_NOSS is negative?",
                        "test": any_unmasked_negative,
                    }
                )
                tests.append(
                    {
                        "name": f"nlr_flux_unmasked_in_{name}",
                        "description": f"Are there unmasked pixels in {ext} where FLUX_NOSS is non-linear?",
                        "test": any_unmasked_nonlinear,
                    }
                )
        return tests
