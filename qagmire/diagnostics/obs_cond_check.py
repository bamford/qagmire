# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/diagnostics/10_obs_cond_check.ipynb.

# %% auto 0
__all__ = ['ObsCondCheck']

# %% ../../nbs/diagnostics/10_obs_cond_check.ipynb 2
import xarray as xr

from qagmire.data import (
    get_lr_l1_single_files,
    read_primary_header,
)
from ..quality_assurance import Diagnostics
from ..utilities import add_expid, parse_obstemp

# %% ../../nbs/diagnostics/10_obs_cond_check.ipynb 4
class ObsCondCheck(Diagnostics):
    """Observing conditions check.

    A reproduction of the weaveio [obs_cond_check](https://github.com/bamford/QAG/blob/master/diagnostics/obs_cond_checks.py).

    This tests for the following cases:

    * Is the sky brighter than the requirement?
    * Is the seeing worse than the requirement?

    and some supplementary tests, if `by_exposure=True`:

    * Are there other than two runs with the same EXPID?
    * Do runs with the same EXPID have different sky brightness?
    * Do runs with the same EXPID have different seeing?

    or if `by_exposure=False`:
    * Are there other than six runs with the same OBID?
    """

    def __init__(
        self,
        sky_tolerance: float = 0.0,  # the tolerance in the sky brightness in magnitudes
        seeing_tolerance: float = 0.0,  # the tolerance in the seeing in arcsec
        by_exposure=True,  # should the checks be performed per exposure (the default), or per OB
    ):
        self.sky_tolerance = sky_tolerance
        self.seeing_tolerance = seeing_tolerance
        self.by_exposure = by_exposure
        if by_exposure:
            self._get_and_check = self._get_and_check_by_exp
        else:
            self._get_and_check = self._get_and_check_by_ob
        super().__init__()

    @staticmethod
    def _restore_coords(coords, da):
        return [d.assign_coords(coords) for d in da]

    @classmethod
    def _get_and_check_by_exp(cls, col):
        col = col.reset_coords("CAMERA", drop=True)
        coords = (
            col.swap_dims(filename="EXPID")
            .coords.to_dataset()
            .reset_coords()
            .groupby("EXPID")
            .first()
        )
        by_exp = col.groupby("EXPID")
        count, first, last = cls._restore_coords(
            coords, (by_exp.count(), by_exp.first(), by_exp.last())
        )
        expected_runs = count == 2
        runs_match = first == last
        return first, expected_runs, runs_match

    @staticmethod
    def _get_and_check_by_ob(col):
        by_ob = col.groupby("OBID")
        with xr.set_options(use_flox=False):
            # flox does not work with .count and string arrays
            count, first = (by_ob.count(), by_ob.first())
        expected_runs = count == 6
        runs_match = (first != col).any(axis=-1)
        return first, expected_runs, runs_match

    def tests(
        self,
        **kwargs,
    ):
        files = get_lr_l1_single_files(**kwargs)
        hdr = read_primary_header(files)
        if self.by_exposure:
            hdr = add_expid(hdr)

        obstemp, count_runs, obstemp_runs_match = self._get_and_check(hdr["OBSTEMP"])
        obs = parse_obstemp(obstemp)

        self.data = (hdr, obs)

        sky, _, sky_runs_match = self._get_and_check(hdr["SKYBRTEL"])
        sky_fail = sky < obs["sky_brightness"] - self.sky_tolerance
        seeing, _, seeing_runs_match = self._get_and_check(hdr["SEEINGB"])
        seeing_fail = seeing > obs["seeing"] + self.seeing_tolerance

        tests = [
            {
                "name": "sky_too_bright",
                "description": "Is the sky brighter than the requirement?",
                "test": sky_fail,
            },
            {
                "name": "seeing_too_poor",
                "description": "Is the seeing worse than the requirement?",
                "test": seeing_fail,
            },
        ]
        if self.by_exposure:
            tests.extend(
                [
                    {
                        "name": "wrong_run_count",
                        "description": "Are there other than two runs with the same EXPID?",
                        "test": ~count_runs,
                    },
                    {
                        "name": "unmatched_runs_sky",
                        "description": "Do runs with the same EXPID have different sky brightness?",
                        "test": ~sky_runs_match,
                    },
                    {
                        "name": "unmatched_runs_seeing",
                        "description": "Do runs with the same EXPID have different seeing?",
                        "test": ~seeing_runs_match,
                    },
                ]
            )
        else:
            tests.extend(
                [
                    {
                        "name": "wrong_run_count",
                        "description": "Are there other than six runs with the same OBID?",
                        "test": ~count_runs,
                    },
                ]
            )

        return tests
