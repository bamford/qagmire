# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/diagnostics/15_sky_noise_distribution_check.ipynb.

# %% auto 0
__all__ = ['palette', 'SkyNoiseDistributionCheck', 'plot_hist', 'plot_dist', 'plot_stack_over_single']

# %% ../../nbs/diagnostics/15_sky_noise_distribution_check.ipynb 3
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
import xarray as xr
from dask.distributed import Client
from scipy.stats import sigmaclip

from ..data import get_weave_files, read_fibre_table_nspec, read_l1_data
from ..quality_assurance import Diagnostics
from ..utilities import ks_norm_prob

# %% ../../nbs/diagnostics/15_sky_noise_distribution_check.ipynb 5
class SkyNoiseDistributionCheck(Diagnostics):
    """Sky noise distribution check.

    A reproduction of the NoisePropCheck classes in the weaveio
    [noise_prop_checks](https://github.com/bamford/QAG/blob/master/diagnostics/noise_prop_checks.py).

    This tests for the following case:

    * Is the mean of the normalised flux in sky fibres significantly different from zero?
    * Is the standard deviation of the normalised flux in sky fibres significantly different from unity?
    * Does the distribution of normalised flux in sky fibres fail a KS test comparison with a standard Normal?

    for "single" and "stack" L1 spectra and for the red and blue cameras.
    """

    def __init__(
        self,
        ks_pvalue_limit: float = 0.01,  # the pvalue below which distributions are considered to differ
        mean_sig_limit: float = 5,  # the significance above which means are considered to differ
        stdev_sig_limit: float = 5,  # the significance above which stdevs are considered to differ
        stack=False,  # if True, check the stack spectra, otherwise check the single spectra
        camera=None,  # limit to a specific camera: RED or BLUE
        **kwargs,  # additional keyword arguments are passed to the `Diagnostics` constructor
    ):
        self.ks_pvalue_limit = ks_pvalue_limit
        self.mean_sig_limit = mean_sig_limit
        self.stdev_sig_limit = stdev_sig_limit
        self.stack = stack
        self.camera = camera.upper() if camera is not None else None
        super().__init__(**kwargs)

    def tests(self, **kwargs):
        filetype = "stack" if self.stack else "single"
        files = get_weave_files(level="L1", lowres=True, filetype=filetype, **kwargs)
        data = read_l1_data(files)

        fibre_table = read_fibre_table_nspec(files)
        data = xr.merge((data, fibre_table))
        data = data.where(data["TARGUSE"] == b"S", drop=True)

        if self.camera is not None:
            camera_match = data["CAMERA"] == self.camera
            data = data.sel(filename=camera_match)
            cameras = [self.camera]
        else:
            cameras = ["RED", "BLUE"]

        # perform the tests by RUN, rather than filename
        data = data.swap_dims(filename="RUN")
        self.data = data

        stats = []
        for camera in cameras:
            camera_match = data["CAMERA"] == camera
            flux, ivar = f"{camera}_FLUX", f"{camera}_IVAR"
            camdata = data[[flux, ivar]].sel(RUN=camera_match)
            camdata = camdata.where(camdata[ivar] > 0)
            camdata = camdata.stack(SPEC=("RUN", "NSPEC"))
            normflux = camdata[flux] * np.sqrt(camdata[ivar])
            exdim = [d for d in normflux.dims if d != "SPEC"][0]
            check_stats = xr.Dataset()
            n = normflux.count(exdim)
            check_stats["stdev_measured"] = camdata[flux].std(exdim, ddof=1)
            check_stats["stdev_expected"] = np.sqrt((1 / camdata[ivar]).mean(exdim))
            check_stats["mean_zscore"] = normflux.mean(exdim)
            check_stats["stdev_zscore"] = normflux.std(exdim, ddof=1)
            check_stats["err_on_mean_zscore"] = check_stats["stdev_zscore"] / np.sqrt(n)
            check_stats["err_on_stdev_zscore"] = check_stats["stdev_zscore"] / np.sqrt(
                2 * n - 2
            )
            check_stats["sig_mean_zscore"] = (
                abs(check_stats["mean_zscore"]) / check_stats["err_on_mean_zscore"]
            )
            check_stats["sig_stdev_zscore"] = (
                abs(check_stats["stdev_zscore"] - 1)
                / check_stats["err_on_stdev_zscore"]
            )
            check_stats["ks_prob"] = ks_norm_prob(normflux)
            stats.append(check_stats)
        check_stats = xr.concat(stats, "SPEC")
        self.stats = check_stats
        check_stats = check_stats.unstack("SPEC")
        # remove apparent dependence of other coords on NSPEC
        for x in check_stats.coords:
            if x not in ("RUN", "NSPEC"):
                check_stats[x] = check_stats[x].isel(NSPEC=0)

        tests = [
            {
                "name": "mean_non_zero",
                "description": "Is the mean of the normalised flux in sky fibres "
                "significantly different from zero?",
                "test": (check_stats["sig_mean_zscore"] > self.mean_sig_limit).where(
                    check_stats["sig_mean_zscore"].notnull()
                ),
            },
            {
                "name": "stdev_non_unit",
                "description": "Is the standard deviation of the normalised flux in "
                "sky fibres significantly different from unity?",
                "test": (check_stats["sig_stdev_zscore"] > self.stdev_sig_limit).where(
                    check_stats["sig_stdev_zscore"].notnull()
                ),
            },
            {
                "name": "ks_non_normal",
                "description": "Does the distribution of normalised flux in sky fibres "
                "fail a KS test comparison with a standard Normal?",
                "test": (check_stats["ks_prob"] < self.ks_pvalue_limit).where(
                    check_stats["sig_stdev_zscore"].notnull()
                ),
            },
        ]
        return tests

# %% ../../nbs/diagnostics/15_sky_noise_distribution_check.ipynb 16
palette = {"RED": "tomato", "BLUE": "skyblue"}


def plot_hist(stats, mean_range=None, stdev_range=None):
    fig, ax = plt.subplots(1, 2, figsize=(12, 4))
    sns.histplot(
        ax=ax[0],
        data=stats,
        x="mean_zscore",
        hue="CAMERA",
        binrange=mean_range,
        element="step",
        palette=palette,
        alpha=0.5,
    )
    ax[0].axvline(0, c="k", ls=":")
    sns.histplot(
        ax=ax[1],
        data=stats,
        x="stdev_zscore",
        hue="CAMERA",
        binrange=stdev_range,
        element="step",
        palette=palette,
        alpha=0.5,
    )
    ax[1].axvline(1, c="k", ls=":")

# %% ../../nbs/diagnostics/15_sky_noise_distribution_check.ipynb 19
def plot_dist(
    stats,
    by="OBID",
    mean_range=None,
    stdev_range=None,
    mean_bw=None,
    stdev_bw=None,
    sigma_clip=5.0,
    inner=None,
):
    fig, ax = plt.subplots(2, 1, figsize=(12, 8), sharex=True)
    if sigma_clip is not None:
        sigclip = sigmaclip(stats["mean_zscore"], sigma_clip, sigma_clip)
        ok = (stats["mean_zscore"] > sigclip.lower) & (
            stats["mean_zscore"] < sigclip.upper
        )
        mean_stats = stats[ok]
    else:
        mean_stats = stats
    sns.violinplot(
        ax=ax[0],
        data=mean_stats,
        x=by,
        y="mean_zscore",
        hue="CAMERA",
        density_norm="width",
        split=True,
        gap=0.2,
        inner=inner,
        palette=palette,
        saturation=1,
        bw_method=mean_bw,
        bw_adjust=0.5,
    )
    ax[0].axhline(0, c="k", ls=":")
    if mean_range is not None:
        ax[0].set_ylim(*mean_range)
    if sigma_clip is not None:
        sigclip = sigmaclip(stats["stdev_zscore"], sigma_clip, sigma_clip)
        ok = (stats["stdev_zscore"] > sigclip.lower) & (
            stats["stdev_zscore"] < sigclip.upper
        )
        stdev_stats = stats[ok]
    else:
        stdev_stats = stats
    sns.violinplot(
        ax=ax[1],
        data=stdev_stats,
        x=by,
        y="stdev_zscore",
        hue="CAMERA",
        density_norm="width",
        split=True,
        gap=0.2,
        inner=inner,
        palette=palette,
        saturation=1,
        bw_method=stdev_bw,
        bw_adjust=0.5,
    )
    ax[1].axhline(1, c="k", ls=":")
    if stdev_range is not None:
        ax[1].set_ylim(*stdev_range)
    fig.subplots_adjust(hspace=0.05)

# %% ../../nbs/diagnostics/15_sky_noise_distribution_check.ipynb 30
def plot_stack_over_single(df):
    fig, ax = plt.subplots(1, 2, figsize=(12, 4))
    sns.histplot(
        ax=ax[0],
        data=df,
        x="stdev_measured",
        hue="CAMERA",
        binrange=(1, 3),
        element="step",
        palette=palette,
        alpha=0.5,
    )
    ax[0].axvline(np.sqrt(3), c="k", ls=":")
    ax[0].set_xlabel("stack / single noise from measured flux")
    sns.histplot(
        ax=ax[1],
        data=df,
        x="stdev_expected",
        hue="CAMERA",
        binrange=(1, 3),
        element="step",
        palette=palette,
        alpha=0.5,
    )
    ax[1].axvline(np.sqrt(3), c="k", ls=":")
    ax[1].set_xlabel("stack / single noise from flux errors")
